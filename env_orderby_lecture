# Django rest_framework에서의 CRUD
    Create : POST
    Read : GET
    Update : PUT
    Delete : ?


# mega_seed Command
    python manage.py mega_seed

# 1.0 APIs the Django Way
    (rooms/views.py)
        from django.core import serializers
        from django.http import HttpResponse
        from rooms.models import Room


        def list_rooms(request):
            data = serializers.serialize("json", Room.objects.all()) # format: json, QuerySet: Room.objects.all()
            response = HttpResponse(content=data)
            return response

    django object를 가지고 있고 JSON으로 바꿔주고 싶다면 serializers를 이용
    무엇인가를 api 혹은 ios 애플리케이션에서 JSON으로 얻고 싶다면 serializers를 이용


# 1.1 @api_view
    (config/urls.py)
        path("api/v1/rooms/", include("rooms.urls"))

    pipenv install djangorestframework
    (config/settings.py)
        THIRD_PARTY_APPS = ["rest_framework"]

    (rooms/views.py)
        from rest_framework.decorators import api_view
        from rest_framework.response import Response


        @api_view(["GET", "POST", "DELETE"])
        def list_rooms(request):
            return Response()
    
    여기까지 해주고 /api/v1/rooms/list/ 로 이동해주면
    List Rooms에 대한 API 사이트? 를 볼 수 있다.
    Django REST Framework에 의해서 제공되는 페이지
    -> Web browsable API


# 1.2 Serializers
    Serializers는 python object를 json으로 또는 그 역으로 바꿔준다. field와 함께(FormField 처럼)
    
    (rooms/serializers.py)
        from rest_framework import serializers

        class RoomSerializer(serializers.Serializer):
            name = serializers.CharField(max_length=140)
            price = serializers.IntegerField()
            bedrooms = serializers.IntegerField()
            instant_book = serializers.BooleanField()

    (rooms/views.py)
        from rest_framework.decorators import api_view
        from rest_framework.response import Response
        from .models import Room
        from .serializers import RoomSerializer

        @api_view(["GET", "POST", "DELETE"])
        def list_rooms(request):
            rooms = Room.objects.all()
            serialized_rooms = RoomSerializer(rooms, many=True)
            return Response(data=serialized_rooms.data)


# 1.3 Serializers part Two
    (rooms/serializers.py)
        from rest_framework import serializers
        from .models import Room

        class RoomSerializer(serializers.ModelSerializer):

            class Meta:
                model = Room
                fields = ("name", "price", "instant_book", "user")

        /api/v1/rooms/list/ 로 이동해주면 fields에서 정해준 것들을 확인 가능
    
    (users/serializers.py)
        from rest_framework import serializers
        from .models import User

        class TinyUserSerializer(serializers.ModelSerializer):
            class Meta:
                model = User
                fields = ("username", "superhost")
    
    (rooms/serializers.py)
        from rest_framework import serializers
        from users.serializers import TinyUserSerializer
        from .models import Room

        class RoomSerializer(serializers.ModelSerializer):

            user = TinyUserSerializer()     # room에서 user를 serialize 하기 위해서, User모델에서 serialize된 user를 가져올 수 있다.

            class Meta:
                model = Room
                fields = ("name", "price", "instant_book", "user")


# 1.4 Class Based Views
    지금까지 한것을 CBV를 통해 똑같이 만들어보자
    (rooms/views.py)
        from rest_framework.views import APIView
        from rest_framework.respnse import Response
        from .models import Room
        from .serializers import RoomSerializer

        class ListRoomView(APIView):
            def get(self, request):
                rooms = Room.objects.all()
                serializer = RoomSerializer(rooms, many=True)
                return Response(serializer.data)
    
    (rooms/urls.py)
        urlpatterns = [path("list/", views.ListRoomView.as_view())]

    그냥 APIView 말고 편하게 쓸 수 있는 GenericView를 보자.
    GenericView 중의 하나인 ListAPIView를 이용하자.

    (rooms/views.py)
        from rest_framework.generics import ListAPIView
        from rest_framework.response import Response
        from .models import Room
        from .serializers import RoomSerializer


        class ListRoomsView(ListAPIView):

            queryset = Room.objects.all()
            serializer_class = RoomSerializer

    ListAPIView를 이용해서 더 짧은 코딩이 이루어졌다.

    Setting the pagination style
        PageNumberPagination
        (config.settings.py)
            # Django Rest Framework
            REST_FRAMEWORK = {
                'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
                'PAGE_SIZE': 10,
            }




# 1.5 ListAPIView
    ccbv.co.uk
    cdrf.co    : 고급 장고 REST 프레임워크 사이트

    (rooms/serializers.py)
        from rest_framework import serializers
        from users.serializers import TinyUserSerializer
        from .models import Room

        class RoomSerializer(serializers.ModelSerializer):

            user = TinyUserSerializer()

            class Meta:
                model = Room
                fields = ("pk", "name", "price", "instant_book", "user")


        class BigRoomSerializer(serializers.ModelSerializer):

            class Meta:
                model = Room
                fields = ("__all__")    # 또는 exclude = ()

    (rooms/views.py)
        from rest_framework.generics import ListAPIView, RetrieveAPIView
        from rest_framework.response import Response
        from .models import Room
        from .serializers import RoomSerializer, BigRoomSerializer


        class ListRoomsView(ListAPIView):

            queryset = Room.objects.all()
            serializer_class = RoomSerializer


        class SeeRoomView(RetrieveAPIView):
            
            queryset = Room.objects.all()
            serializer_class = BigRoomSerializer
            # lookup_url_kwarg = "pkkk"     # lookup_url_kwarg로 pk를 pkkk 등 원하는 것으로 변경 가능

    (rooms/urls.py)
        from django.urls import path
        from . import views

        app_name = "rooms"

        urlpatterns = [
            path("list/", views.ListRoomsView.as_view()),
            path("<int:pk>/", views.SeeRoomView.as_view()),
        ]

    여기까지 하면, 특정 room에 대한 API 정보?페이지에 접근 가능
    ex) /api/v1/rooms/42/


# 1.6 ModelViewSet
    ModelViewSet을 이용하면, Views.py에 아예 적을 필요가 없다.
    (rooms/viewsets.py)
        from rest_framework import viewsets
        from .models import Room
        from .serializers import BigRoomSerializer

        class RoomViewset(viewsets.ModelViewSet):
            queryset = Room.objects.all()
            serializer_class = BigRoomSerializer
    
    또한, urls를 기존과는 다른 방식으로 사용: router
    (rooms/urls.py)
        from rest_framework.routers import DefaultRouter
        from django.urls import path
        from . import viewsets


        app_name = "rooms"

        router = DefaultRouter()
        router.register("", viewsets.RoomViewset, basename="room")

        urlpatterns = router.urls

    이렇게 하고 api 페이지를 보면, views.py를 전혀 호출하지 않았는데 기존에 views.py에 정의해준 것들을 모두 이용하고있는 것을 볼 수 있다.
    모든 것이 오픈되어 있는 것이 단점


# 1.7 Bye Bye ViewSet


# 2.0 ListRoomsView & SeeRoomView
    (users/serializers.py)
        from rest_framework import serializers
        from .models import User

        class UserSerializer(serializers.ModelSerializer):
            class Meta:
                model = User
                exclude = (
                    "groups",
                    "user_permissions",
                    "password",
                    "last_login",
                    "is_superuser",
                    "is_staff",
                    "is_active",
                    "date_joined",
                    "favs",
                )

    (rooms/serializers.py)
        from rest_framework import serializers
        from users.serializers import UserSerializer
        from .models import Room

        class RoomSerializer(serializers.ModelSerializer):

            user = UserSerializer()

            class Meta:
                model = Room
                exclude = ("modified",)

    (roms/views.py)
        from rest_framework.generics import ListAPIView, RetrieveAPIView
        from rest_framework.response import Response
        from .models import Room
        from .serializers import RoomSerializer


        class ListRoomsView(ListAPIView):

            queryset = Room.objects.all()
            serializer_class = RoomSerializer


        class SeeRoomView(RetrieveAPIView):
            
            queryset = Room.objects.all()
            serializer_class = RoomSerializer


# 2.1 Create Room part One
    (rooms/serializers.py)
        from rest_framework import serializers
        from users.serializers import UserSerializer
        from .models import Room

        class ReadRoomSerializer(serializers.ModelSerializer):

            user = UserSerializer()

            class Meta:
                model = Room
                exclude = ("modified",)


        class WriteRoomSerializer(serializers.Serializer):

            name = serializers.CharField(max_length=140)
            address = serializers.CharField(max_length=140)
            price = serializers.IntegerField()
            beds = serializers.IntegerField(default=1)
            lat = serializers.DecimalField(max_digits=10, decimal_places=6)
            lng = serializers.DecimalField(max_digits=10, decimal_places=6)
            bedrooms = serializers.IntegerField(default=1)
            bathrooms = serializers.IntegerField(default=1)
            check_in = serializers.TimeField(default="00:00:00")
            check_out = serializers.TimeField(default="00:00:00")
            instant_book = serializers.BooleanField(default=False)

    (rooms/views.py)
        from rest_framework.generics import RetrieveAPIView
        from rest_framework.decorators import api_view
        from rest_framework.response import Response
        from rest_framework import status
        from .models import Room
        from .serializers import ReadRoomSerializer, WriteRoomSerializer


        @api_view(["GET", "POST"])
        def rooms_view(request):
            if request.method == "GET":
                rooms = Room.objects.all()
                serializer = ReadRoomSerializer(rooms, many=True).data
                return Response(serializer)
            elif request.method == "POST":
                serializer = WriteRoomSerializer(data=request.data)
                if serializer.is_valid():
                    return Response(status=status.HTTP_200_OK)
                else:
                    return Response(status=status.HTTP_400_BAD_REQUEST)


        class SeeRoomView(RetrieveAPIView):
            
            queryset = Room.objects.all()
            serializer_class = ReadRoomSerializer

    (rooms/urls.py)
        from django.urls import path
        from . import views


        app_name = "rooms"


        urlpatterns = [
            path("", views.rooms_view),
            path("<int:pk>/", views.SeeRoomView.as_view()),
        ]


# 2.2 Create Room part Two
    (rooms/serializers.py)
        from rest_framework import serializers
        from users.serializers import UserSerializer
        from .models import Room


        class ReadRoomSerializer(serializers.ModelSerializer):

            user = UserSerializer()

            class Meta:
                model = Room
                exclude = ("modified",)


        class WriteRoomSerializer(serializers.Serializer):

            name = serializers.CharField(max_length=140)
            address = serializers.CharField(max_length=140)
            price = serializers.IntegerField()
            beds = serializers.IntegerField(default=1)
            lat = serializers.DecimalField(max_digits=10, decimal_places=6)
            lng = serializers.DecimalField(max_digits=10, decimal_places=6)
            bedrooms = serializers.IntegerField(default=1)
            bathrooms = serializers.IntegerField(default=1)
            check_in = serializers.TimeField(default="00:00:00")
            check_out = serializers.TimeField(default="00:00:00")
            instant_book = serializers.BooleanField(default=False)

            def create(self, validated_data):                   # rooms/views.py에서 작성한 print(dir(serializer))를 통해서 확인한 method를 활용(create)
                return Room.objects.create(**validated_data)

        # 특히 serializer에 있는 method 중 다음 3가지를 유용하게 쓸 수 있다.
            create, update, save

    (rooms/views.py)
        from rest_framework.generics import RetrieveAPIView
        from rest_framework.decorators import api_view
        from rest_framework.response import Response
        from rest_framework import status
        from .models import Room
        from .serializers import ReadRoomSerializer, WriteRoomSerializer


        @api_view(["GET", "POST"])
        def rooms_view(request):
            if request.method == "GET":
                rooms = Room.objects.all()[:5]
                serializer = ReadRoomSerializer(rooms, many=True).data
                return Response(serializer)
            elif request.method == "POST":
                if not request.user.is_authenticated:
                    return Response(status=status.HTTP_401_UNAUTHORIZED)
                serializer = WriteRoomSerializer(data=request.data)
                print(dir(serializer))              # dir(serializer) 를 통해 내부 method를 보고 활용
                if serializer.is_valid():          
                    room = serializer.save(user=request.user)       # rooms/serializers.py에서 create 해준 serializer를 save
                                                                    # save method는 create인지 update인지 자동으로 감지
                                                                    # create, update를 직접 call하면 안되고, save를 통해야 한다.
                                                                    # create method는 object instance를 return 해야 한다.
                    room_serializer = ReadRoomSerializer(room).data
                    return Response(data=room_serializer, status=status.HTTP_200_OK)
                else:
                    return Response(status=status.HTTP_400_BAD_REQUEST)


        class SeeRoomView(RetrieveAPIView):

            queryset = Room.objects.all()
            serializer_class = ReadRoomSerializer

    (rooms/models.py)
        class Room(CoreModel):

            class Meta:
                ordering = ["-pk"]      # 생성된 room을 최상단에서 보려고 수정


# 2.3 Room Detail GET

    (rooms/serializers.py)
        from rest_framework import serializers
        from users.serializers import UserSerializer
        from .models import Room


        class ReadRoomSerializer(serializers.ModelSerializer):

            user = UserSerializer()

            class Meta:
                model = Room
                exclude = ("modified",)


        class WriteRoomSerializer(serializers.Serializer):

            name = serializers.CharField(max_length=140)
            address = serializers.CharField(max_length=140)
            price = serializers.IntegerField()
            beds = serializers.IntegerField(default=1)
            lat = serializers.DecimalField(max_digits=10, decimal_places=6)
            lng = serializers.DecimalField(max_digits=10, decimal_places=6)
            bedrooms = serializers.IntegerField(default=1)
            bathrooms = serializers.IntegerField(default=1)
            check_in = serializers.TimeField(default="00:00:00")
            check_out = serializers.TimeField(default="00:00:00")
            instant_book = serializers.BooleanField(default=False)

            def create(self, validated_data):
                return Room.objects.create(**validated_data)

            def validate(self, data):                   # def validate는 전부에 대한 접근(두가지 등 한번에 validate 할 때), 특정 부분에 접근시에는 def validate_beds 등의 방식으로 정의
                if not self.instance:
                    check_in = data.get('check_in')
                    check_out = data.get('check_out')
                    if check_in == check_out:
                        raise serializers.ValidationError("Not enough time between changes")
                return data

    (rooms/views.py)
        from django.http.response import Http404
        from rest_framework.views import APIView
        from rest_framework.response import Response
        from rest_framework import status
        from .models import Room
        from .serializers import ReadRoomSerializer, WriteRoomSerializer


        class RoomsView(APIView):               #  이와 같이 FBV를 CBV로 변경 가능(동일하게 표시 되어야 한다. 단, url 수정)

            def get(self, request):
                rooms = Room.objects.all()[:5]
                serializer = ReadRoomSerializer(rooms, many=True).data
                return Response(serializer)

            def post(self, request):
                if not request.user.is_authenticated:
                    return Response(status=status.HTTP_401_UNAUTHORIZED)
                serializer = WriteRoomSerializer(data=request.data)
                if serializer.is_valid():
                    room = serializer.save(user=request.user)
                    room_serializer = ReadRoomSerializer(room).data
                    return Response(data=room_serializer, status=status.HTTP_200_OK)
                else:
                    return Response(data=serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        
        class RoomView(APIView):              # RetrieveAPIView를 없애고 APIView로 대체해보자
            def get(self, request, pk):
                try:
                    room = Room.objects.get(pk=pk)
                    serializer = ReadRoomSerializer(room).data
                    return Response(serializer)
                except Room.DoesNotExist:
                    return Response(status=status.HTTP_404_NOT_FOUND)

            def put(self, request):
                pass

            def delete(self, request):
                pass


# 2.4 Room Detail DELETE PUT part One
    (rooms/views.py)
        from django.http.response import Http404
        from rest_framework.views import APIView
        from rest_framework.response import Response
        from rest_framework import status
        from .models import Room
        from .serializers import ReadRoomSerializer, WriteRoomSerializer


        class RoomsView(APIView):

            def get(self, request):
                rooms = Room.objects.all()[:5]
                serializer = ReadRoomSerializer(rooms, many=True).data
                return Response(serializer)

            def post(self, request):
                if not request.user.is_authenticated:
                    return Response(status=status.HTTP_401_UNAUTHORIZED)
                serializer = WriteRoomSerializer(data=request.data)
                if serializer.is_valid():
                    room = serializer.save(user=request.user)
                    room_serializer = ReadRoomSerializer(room).data
                    return Response(data=room_serializer, status=status.HTTP_200_OK)
                else:
                    return Response(data=serializer.errors, status=status.HTTP_400_BAD_REQUEST)


        class RoomView(APIView):

            def get_room(self, pk):                         # 계속 반복되는 method라 미리 만들어둚
                try:
                    room = Room.objects.get(pk=pk)
                    return room
                except Room.DoesNotExist:
                    return None

            def get(self, request, pk):
                room = self.get_room(pk)                     # 위에서 만들어둔 get_room method 활용
                if room is not None:
                    serializer = ReadRoomSerializer(room).data
                    return Response(serializer)
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)

            def put(self, request, pk):
                pass

            def delete(self, request, pk):
                room = self.get_room(pk)
                if room.user != request.user:
                    return Response(status=status.HTTP_403_FORBIDDEN)
                if room is not None:
                    room.delete()
                    return Response(status=status.HTTP_200_OK)
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)

    (rooms/serializers.py)
        from rest_framework import serializers
        from users.serializers import UserSerializer
        from .models import Room


        class ReadRoomSerializer(serializers.ModelSerializer):

            user = UserSerializer()

            class Meta:
                model = Room
                exclude = ("modified",)


        class WriteRoomSerializer(serializers.Serializer):

            name = serializers.CharField(max_length=140)
            address = serializers.CharField(max_length=140)
            price = serializers.IntegerField()
            beds = serializers.IntegerField(default=1)
            lat = serializers.DecimalField(max_digits=10, decimal_places=6)
            lng = serializers.DecimalField(max_digits=10, decimal_places=6)
            bedrooms = serializers.IntegerField(default=1)
            bathrooms = serializers.IntegerField(default=1)
            check_in = serializers.TimeField(default="00:00:00")
            check_out = serializers.TimeField(default="00:00:00")
            instant_book = serializers.BooleanField(default=False)

            def create(self, validated_data):
                return Room.objects.create(**validated_data)

            def validate(self, data):
                if not self.instance:
                    check_in = data.get('check_in')
                    check_out = data.get('check_out')
                    if check_in == check_out:
                        raise serializers.ValidationError("Not enough time between changes")
                return data
            

            def update(self, instance, validated_data):     # update method는 instance라는 인자를 갖는데, 이로 인해서 django가 create인지 update인지 구분할 수가 있다.
                                                            # RoomsView에서 room을 post를 통해 create 한다면 serialier를 data만을 이용해서 initialize 한다.
                                                            # update를 한다면, instance를 가지고 serializer를 initialize 해야하는 것을 알려주기 때문에 create, update를 save가 자동으로 구분
                                                            # 이제 이를 이용해서 views.py/RoomView의 put을 채워보자
                print(instance, validated_data)
                return Room.objects.update(**validated_date)             


    (rooms/views.py)
        from django.http.response import Http404
        from rest_framework.views import APIView
        from rest_framework.response import Response
        from rest_framework import status
        from .models import Room
        from .serializers import ReadRoomSerializer, WriteRoomSerializer


        class RoomsView(APIView):

            def get(self, request):
                rooms = Room.objects.all()[:5]
                serializer = ReadRoomSerializer(rooms, many=True).data
                return Response(serializer)

            def post(self, request):
                if not request.user.is_authenticated:
                    return Response(status=status.HTTP_401_UNAUTHORIZED)
                serializer = WriteRoomSerializer(data=request.data)
                if serializer.is_valid():
                    room = serializer.save(user=request.user)
                    room_serializer = ReadRoomSerializer(room).data
                    return Response(data=room_serializer, status=status.HTTP_200_OK)
                else:
                    return Response(data=serializer.errors, status=status.HTTP_400_BAD_REQUEST)


        class RoomView(APIView):

            def get_room(self, pk):
                try:
                    room = Room.objects.get(pk=pk)
                    return room
                except Room.DoesNotExist:
                    return None

            def get(self, request, pk):
                room = self.get_room(pk)
                if room is not None:
                    serializer = ReadRoomSerializer(room).data
                    return Response(serializer)
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)

            def put(self, request, pk):
                room = self.get_room(pk)
                if room is not None:
                    if room.user != request.user:
                        return Response(status=status.HTTP_403_FORBIDDEN)
                    serializer = WriteRoomSerializer(room, data=request.data, partial=True)     # room이 instance가 된다 - 이 room을 넣지 않으면 serializer는 update가 아닌 create하는 것으로 인지한다.  
                                                                                                # partial=True: 데이터를 모두 보내는 것이 아니라 내가 바꾸고 싶은 데이터만 보내게 하는 것
                    if serializer.is_valid():
                        serializer.save()
                    else:
                        return Response(serializer.erros, status=status.HTTP_400_BAD_REQUEST)
                    return Response()
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)

            def delete(self, request, pk):
                room = self.get_room(pk)
                if room.user != request.user:
                    return Response(status=status.HTTP_403_FORBIDDEN)
                if room is not None:
                    room.delete()
                    return Response(status=status.HTTP_200_OK)
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)


# 2.5 Room Detail PUT part Two
    (rooms/serializers.py)
        from rest_framework import serializers
        from users.serializers import UserSerializer
        from .models import Room


        class ReadRoomSerializer(serializers.ModelSerializer):

            user = UserSerializer()

            class Meta:
                model = Room
                exclude = ("modified",)


        class WriteRoomSerializer(serializers.Serializer):

            name = serializers.CharField(max_length=140)
            address = serializers.CharField(max_length=140)
            price = serializers.IntegerField()
            beds = serializers.IntegerField(default=1)
            lat = serializers.DecimalField(max_digits=10, decimal_places=6)
            lng = serializers.DecimalField(max_digits=10, decimal_places=6)
            bedrooms = serializers.IntegerField(default=1)
            bathrooms = serializers.IntegerField(default=1)
            check_in = serializers.TimeField(default="00:00:00")
            check_out = serializers.TimeField(default="00:00:00")
            instant_book = serializers.BooleanField(default=False)

            def create(self, validated_data):
                return Room.objects.create(**validated_data)

            def validate(self, data):
                if self.instance:                                               # update 할 때
                    check_in = data.get('check_in', self.instance.check_in)     # update 할 때는 check_in, check_out을 수정하지 않을 수 있다. 그때는 self.instance.check_in 에 이미 있는 값을 default로 가져온다.
                    check_out = data.get('check_out', self.instance.check_out)
                else:                                                           # create 할 때
                    check_in = data.get('check_in')
                    check_out = data.get('check_out')
                if check_in == check_out:
                    raise serializers.ValidationError(
                        "Not enough time between changes")
                return data

            def update(self, instance, validated_data):
                instance.name = validated_data.get("name", instance.name)
                instance.address = validated_data.get("address", instance.address)
                instance.price = validated_data.get("price", instance.price)
                instance.beds = validated_data.get("beds", instance.beds)
                instance.lat = validated_data.get("lat", instance.lat)
                instance.lng = validated_data.get("lng", instance.lng)
                instance.bedrooms = validated_data.get("bedrooms", instance.bedrooms)
                instance.bathrooms = validated_data.get("bathrooms", instance.bathrooms)
                instance.check_in = validated_data.get("check_in", instance.check_in)
                instance.check_out = validated_data.get("check_out", instance.check_out)
                instance.instant_book = validated_data.get("instant_book", instance.instant_book)
                instance.save()
                return instance

            # def update(self, instance, validated_data): 
            #     return Room.objects.update(**validated_data)            # update를 다음과 같이 정의해도 되는 것 같음. 확인 필요
            #                                                             # 정보가 수정되긴 하는데, 다음과 같은 오류 발생: 
                                                                        # Got AttributeError when attempting to get a value for field `user` on serializer `ReadRoomSerializer`.
                                                                        # The serializer field might be named incorrectly and not match any attribute or key on the `int` instance.
                                                                        # Original exception text was: 'int' object has no attribute 'user'.

    (rooms/views.py)
        from django.http.response import Http404
        from rest_framework.views import APIView
        from rest_framework.response import Response
        from rest_framework import status
        from .models import Room
        from .serializers import ReadRoomSerializer, WriteRoomSerializer


        class RoomsView(APIView):

            def get(self, request):
                rooms = Room.objects.all()[:5]
                serializer = ReadRoomSerializer(rooms, many=True).data
                return Response(serializer)

            def post(self, request):
                if not request.user.is_authenticated:
                    return Response(status=status.HTTP_401_UNAUTHORIZED)
                serializer = WriteRoomSerializer(data=request.data)
                if serializer.is_valid():
                    room = serializer.save(user=request.user)
                    room_serializer = ReadRoomSerializer(room).data
                    return Response(data=room_serializer, status=status.HTTP_200_OK)
                else:
                    return Response(data=serializer.errors, status=status.HTTP_400_BAD_REQUEST)


        class RoomView(APIView):

            def get_room(self, pk):
                try:
                    room = Room.objects.get(pk=pk)
                    return room
                except Room.DoesNotExist:
                    return None

            def get(self, request, pk):
                room = self.get_room(pk)
                if room is not None:
                    serializer = ReadRoomSerializer(room).data
                    return Response(serializer)
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)

            def put(self, request, pk):
                room = self.get_room(pk)
                if room is not None:
                    if room.user != request.user:
                        return Response(status=status.HTTP_403_FORBIDDEN)
                    serializer = WriteRoomSerializer(
                        room, data=request.data, partial=True)
                    # print(serializer.is_valid(), serializer.errors)         # 오류가 나는지, 어떤 오류가 나는지를 파악해서 수정하자
                    if serializer.is_valid():                                 # 여기 아래 두줄이 지난강의에서 추가된 부분
                        room = serializer.save()
                        return Response(ReadRoomSerializer(room).data)
                    else:
                        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
                    return Response()
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)

            def delete(self, request, pk):
                room = self.get_room(pk)
                if room.user != request.user:
                    return Response(status=status.HTTP_403_FORBIDDEN)
                if room is not None:
                    room.delete()
                    return Response(status=status.HTTP_200_OK)
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)


    # 2.6 MeView and user_detail

        (users/views.py)
            from rest_framework.decorators import api_view
            from rest_framework.views import APIView


            class MeView(APIView):

                def get(self, request):
                    pass

                def put(self, request):
                    pass



            @api_view(["GET"])
            def user_detail(request, pk):
                pass

        (users/urls.py)
            from django.urls import path
            from . import views

            app_name = "users"

            urlpatterns = [
                path("me/", views.MeView.as_view()),
                path("<int:pk>/", views.user_detail)
            ]

        (users/serializers.py)
            from rest_framework import serializers
            from .models import User

            class RelatedUserSerializer(serializers.ModelSerializer):
                class Meta:
                    model = User
                    fields = (
                        "username",
                        "first_name",
                        "last_name",
                        "email",
                        "avatar",
                        "superhost"
                    )
                    # fields = ("username", "superhost")


            class ReadUserSerializer(serializers.ModelSerializer):
                class Meta:
                    model = User
                    exclude = (
                        "groups",
                        "user_permissions",
                        "password",
                        "last_login",
                        "is_superuser",
                        "is_staff",
                        "is_active",
                        "date_joined",
                    )
        
        (rooms/serializers.py)
            from rest_framework import serializers
            from users.serializers import RelatedUserSerializer     # 수정
            from .models import Room


            class ReadRoomSerializer(serializers.ModelSerializer):

                user = RelatedUserSerializer()      # 수정

                class Meta:
                    model = Room
                    exclude = ("modified",)

        (users/serializers.py)
            from users.serializers import ReadUserSerializer
            from rest_framework.response import Response
            from rest_framework.decorators import api_view
            from rest_framework.views import APIView
            from rest_framework import status
            from .serializers import ReadUserSerializer
            from .models import User


            class MeView(APIView):

                def get(self, request):
                    if request.user.is_authenticated:             # is_authenticated()라고 하면 'bool' object is not callable 라는 오류 발생
                        return Response(ReadUserSerializer(request.user).data)

                def put(self, request):
                    pass



            @api_view(["GET"])
            def user_detail(request, pk):
                try:
                    user = User.objects.get(pk=pk)
                    return Response(ReadUserSerializer(user).data)
                except User.DoesNotExist:
                    return Response(status=status.HTTP_404_NOT_FOUND)


# 2.6 MeView PUT

    (users/views.py)
        from users.serializers import ReadUserSerializer
        from rest_framework.response import Response
        from rest_framework.permissions import IsAuthenticated
        from rest_framework.decorators import api_view
        from rest_framework.views import APIView
        from rest_framework import status
        from .serializers import ReadUserSerializer
        from .models import User


        class MeView(APIView):
            
            permission_classes = [IsAuthenticated]

            def get(self, request):
                return Response(ReadUserSerializer(request.user).data)

        # is_authenticated 를 쓰지 않고, permission_classes를 사용 -> if문으로 is_authenticated를 사용하면, else의 경우도 정의해줘야 돼서 번거로운데 permission_classes 는 이를 해결해준다 함
        # FBV에 쓸때는 다음과 같이 decorator로 쓰면됨
        # @permission_classes([IsAuthenticated])


    (users/serializers.py)
        class WriteUserSerializer(serializers.ModelSerializer):
            class Meta:
                model = User
                fields = (
                    "username",
                    "first_name",
                    "last_name",
                    "email"
                )


    (users/views.py)
        from users.serializers import ReadUserSerializer
        from rest_framework.response import Response
        from rest_framework.permissions import IsAuthenticated
        from rest_framework.decorators import api_view
        from rest_framework.views import APIView
        from rest_framework import status
        from .serializers import ReadUserSerializer, WriteUserSerializer
        from .models import User


        class MeView(APIView):
            
            permission_classes = [IsAuthenticated]

            def get(self, request):
                return Response(ReadUserSerializer(request.user).data)

            def put(self, request):
                serializer = WriteUserSerializer(request.user, data=request.data, partial=True)        # request.user: instance임
                if serializer.is_valid():
                    serializer.save()
                    return Response()
                else:
                    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        # 이렇게 ModelSerializer를 쓰면, update 할 때 모든 instance를 쓰는 것 등은 안해도 된다..?
        # ModelSerializer에 validate가 필요한 경우. 예를 들어 다음과 같이 해서 저장한 값을 대문자로 해주는 validate 적용 가능
            (users/serializers.py)
                class WriteUserSerializer(serializers.ModelSerializer):
                    class Meta:
                        model = User
                        fields = (
                            "username",
                            "first_name",
                            "last_name",
                            "email"
                        )

                    def validate_first_name(self, value):
                        return value.upper()

    ModelSerializer로 rooms/serializers.py/WriteRoomSerializer도 짧게 바꿔보자
        (rooms/serializers.py)
            from rest_framework import serializers
            from users.serializers import RelatedUserSerializer
            from .models import Room


            class ReadRoomSerializer(serializers.ModelSerializer):

                user = RelatedUserSerializer()

                class Meta:
                    model = Room
                    exclude = ("modified",)


            class WriteRoomSerializer(serializers.ModelSerializer):
                class Meta:
                    model = Room
                    exclude = ("user", "modified", "created")

                
                def validate(self, data):
                    if self.instance:                                               # update 할 때
                        check_in = data.get('check_in', self.instance.check_in)     # update 할 때는 check_in, check_out을 수정하지 않을 수 있다. 그때는 self.instance.check_in 에 이미 있는 값을 default로 가져온다.
                        check_out = data.get('check_out', self.instance.check_out)
                    else:                                                           # create 할 때
                        check_in = data.get('check_in')
                        check_out = data.get('check_out')
                    if check_in == check_out:
                        raise serializers.ValidationError(
                            "Not enough time between changes")
                    return data


    # fav를 작성해보자

# 2.8 Magic + FavsView
    (users/views.py)
        from rooms.models import Room
        from users.serializers import ReadUserSerializer
        from rest_framework.response import Response
        from rest_framework.permissions import IsAuthenticated
        from rest_framework.decorators import api_view
        from rest_framework.views import APIView
        from rest_framework import status
        from rooms.serializers import RoomSerializer
        from .serializers import ReadUserSerializer, WriteUserSerializer
        from .models import User


        class MeView(APIView):
            
            permission_classes = [IsAuthenticated]

            def get(self, request):
                return Response(ReadUserSerializer(request.user).data)

            def put(self, request):
                serializer = WriteUserSerializer(request.user, data=request.data, partial=True)        # request.user: instance임
                if serializer.is_valid():
                    serializer.save()
                    return Response()
                else:
                    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


        @api_view(["GET"])
        def user_detail(request, pk):
            try:
                user = User.objects.get(pk=pk)
                return Response(ReadUserSerializer(user).data)
            except User.DoesNotExist:
                return Response(status=status.HTTP_404_NOT_FOUND)


        # @api_view(["GET", "POST"])     # database의 state를 바꿔주기 때문에 GET이 아닌 POST 이어야 한다??     # 아래 FavsView 하기 전에 시도되었던 FBV
        # @permission_classes([IsAuthenticated])    # 이용해주려면, from rest_framework.decorators import permission_classes 호출
        # def toggle_fav(request):
        #     room = request.data.get("room")
        #     print(room)


        class FavsView(APIView):

            permission_classes = [IsAuthenticated]

            def get(self, request):
                user = request.user
                serializer = RoomSerializer(user.favs.all(), many=True).data
                return Response(serializer)

            def put(self, request):             # favs를 만드는 것이 아니라, 있는 favs를 수정해주는 것이니까 post가 아니라 put method
                pass

    (users/urls.py)
        from django.urls import path
        from . import views

        app_name = "users"

        urlpatterns = [
            path("me/", views.MeView.as_view()),
            path("me/fav/", views.FavsView.as_view()),
            path("<int:pk>/", views.user_detail)
        ]

    (users/serializers.py)
        class ReadUserSerializer(serializers.ModelSerializer):
            class Meta:
                model = User
                exclude = (
                    "groups",
                    "user_permissions",
                    "password",
                    "last_login",
                    "is_superuser",
                    "is_staff",
                    "is_active",
                    "favs",
                    "date_joined",
                )


# 2.9 FavsView part Two

    (users/admin.py)
        from django.contrib import admin
        from django.contrib.auth.admin import UserAdmin
        from . import models


        @admin.register(models.User)
        class UserAdmin(UserAdmin):

            fieldsets = UserAdmin.fieldsets + (
                ("Custom Profile", {"fields": ("avatar", "superhost", "favs")},),
            )

            list_display = UserAdmin.list_display + ("room_count",)

    (users/views.py)
        from rooms.models import Room
        from users.serializers import ReadUserSerializer
        from rest_framework.response import Response
        from rest_framework.permissions import IsAuthenticated
        from rest_framework.decorators import api_view
        from rest_framework.views import APIView
        from rest_framework import status
        from rooms.serializers import RoomSerializer
        from rooms.models import Room
        from .serializers import ReadUserSerializer, WriteUserSerializer
        from .models import User


        class MeView(APIView):
            
            permission_classes = [IsAuthenticated]

            def get(self, request):
                return Response(ReadUserSerializer(request.user).data)

            def put(self, request):
                serializer = WriteUserSerializer(request.user, data=request.data, partial=True)        # request.user: instance임
                if serializer.is_valid():
                    serializer.save()
                    return Response()
                else:
                    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


        @api_view(["GET"])
        def user_detail(request, pk):
            try:
                user = User.objects.get(pk=pk)
                return Response(ReadUserSerializer(user).data)
            except User.DoesNotExist:
                return Response(status=status.HTTP_404_NOT_FOUND)


        # @api_view(["GET", "POST"])     # database의 state를 바꿔주기 때문에 GET이 아닌 POST 이어야 한다??     # 아래 FavsView 하기 전에 시도되었던 FBV
        # @permission_classes([IsAuthenticated])    # 이용해주려면, from rest_framework.decorators import permission_classes 호출
        # def toggle_fav(request):
        #     room = request.data.get("room")
        #     print(room)


        class FavsView(APIView):

            permission_classes = [IsAuthenticated]

            def get(self, request):
                user = request.user
                serializer = RoomSerializer(user.favs.all(), many=True).data
                return Response(serializer)

            def put(self, request):             # favs를 만드는 것이 아니라, 있는 favs를 수정해주는 것이니까 post가 아니라 put method
                pk = request.data.get("pk", None)
                user = request.user
                if pk is not None:
                    try:
                        room = Room.objects.get(pk=pk)
                        if room in user.favs.all():
                            user.favs.remove(room)
                        else:
                            user.favs.add(room)
                        return Response()
                    except Room.DoesNotExist:
                        pass
                return Response(status=status.HTTP_400_BAD_REQUEST)


# 2.10 Creating Account
    (users/serializers.py)
        from rest_framework import serializers
        from .models import User

        class RelatedUserSerializer(serializers.ModelSerializer):
            class Meta:
                model = User
                fields = (
                    "username",
                    "first_name",
                    "last_name",
                    "email",
                    "avatar",
                    "superhost"
                )
                # fields = ("username", "superhost")




        class UserSerializer(serializers.ModelSerializer):
            class Meta:
                model = User
                fields = (
                    "id",
                    "username",
                    "first_name",
                    "last_name",
                    "email",
                    "avatar",
                    "superhost",
                )
                read_only_fields = (
                    "id",
                    "superhost",
                    "avatar"
                )

            # def validate_last_name(self, value):            # validate로 대문자로 저장해보기
            #     return value.upper()

    (users/views.py)
     WriteUserSerializer, ReadUserSerializer 모두 UserSerializer로 변경


     # post user (create user)를 만들어보자

     (users/views.py)
        class UsersView(APIView):
            
            def post(self, request):
                serializer = UserSerializer(data=request.data)
                if serializer.is_valid():
                    new_user = serializer.save()
                    return Response(UserSerializer(new_user).data)
                else:
                    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    (users/urls.py)
        from django.urls import path
        from . import views

        app_name = "users"

        urlpatterns = [
            path("", views.UsersView.as_view()),
            path("me/", views.MeView.as_view()),
            path("me/favs/", views.FavsView.as_view()),
            path("<int:pk>/", views.user_detail)
        ]

    
    # create method를 이용해보자 
        create method를 이용해서 save까지 해줘야 비밀번호 등 제대로 입력 되는 듯
    (users/serializers.py)
        class UserSerializer(serializers.ModelSerializer):

            password = serializers.CharField(write_only=True)       # field에 password를 표기하지만(create 등 하기 위해서), read는 할 수 없게 write_only 설정

            class Meta:
                model = User
                fields = (
                    "id",
                    "username",
                    "first_name",
                    "last_name",
                    "email",
                    "avatar",
                    "superhost",
                    "password"
                )
                read_only_fields = (
                    "id",
                    "superhost",
                    "avatar"
                )

            def create(self, validated_data):
                password = validated_data.get("password")
                user = super().create(validated_data)
                user.set_password(password)
                user.save()
                return user


# 2.11 Log In(JWT)
    (users/views.py)
        from django.contrib.auth import authenticate

        @api_view(["POST"])
        def login(request):
            username = request.data.get("username")
            password = request.data.get("password")
            if not username or not password:
                return Response(status=status.HTTP_400_BAD_REQUEST)
            user = authenticate(username=username, password=password)
            print(user)

    (users/urls.py)
        from django.urls import path
        from . import views

        app_name = "users"

        urlpatterns = [
            path("", views.UsersView.as_view()),
            path("token/", views.login),
            path("me/", views.MeView.as_view()),
            path("me/favs/", views.FavsView.as_view()),
            path("<int:pk>/", views.user_detail)
        ]


    위와 같이 하고 rest_framework에서

    {
        "username":"taltal",
        "password":123
    }

    으로 POST 하면 'taltal'이 출력,
    만약 password 1234 등으로 하면 None이 출력. 되면 authenticate 기능 제대로 작동하는 것임

    # 이제 JWT 를 이용해보자
        설치: pipenv install pyjwt

    (users/views.py)
        @api_view(["POST"])
        def login(request):
            username = request.data.get("username")
            password = request.data.get("password")
            if not username or not password:
                return Response(status=status.HTTP_400_BAD_REQUEST)
            user = authenticate(username=username, password=password)
            if user is not None:
                encoded_jwt = jwt.encode({"id": user.pk}, settings.SECRET_KEY, algorithm="HS256")   # 형식: encoded_jwt = jwt.encode({"some": "payload"}, "secret", algorithm="HS256")
                print(encoded_jwt)
                return Response(data={"token": encoded_jwt})
            else:
                return Response(status=status.HTTP_401_UNAUTHORIZED)

        username, password 올바르게 POST 시에 token이 출력
        출력된 token을 복사해서 jwt.io 홈페이지에 복사해서 보면 Decoded 된 자료를 확인(해석) 할 수 있다.

        ** 개발할 때 JWT에 중요 자료를 담지 말아야 한다. 비밀번호 등은 X
            user를 식별할 수 있는 수준의 id(pk) 정도만 담아야 한다. username, email도 넣지 말아라
            그런데 왜 JWT를 사용하는 것인가?
            우리 server는 token에 변경사항이 있는지를 판단한다. 인증 할 때, 누구도 이 token을 건들지 않았다는 것을 확인하는 것임


# 2.12 JWT Decoding and Auth
    (config/settings.py)
        REST_FRAMEWORK = {
            'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
            'PAGE_SIZE': 10,
            'DEFAULT_AUTHENTICATION_CLASSES': [                             # Django RESR framework API Guid authentication에서 가져오기 https://www.django-rest-framework.org/api-guide/authentication/
                # 'rest_framework.authentication.BasicAuthentication',        # 둘 중 한가지 선택, 강의에서는 SessionAuthentication을 이용하자
                'rest_framework.authentication.SessionAuthentication',  
            ]
        }

    token을 통해서 유저 인증등을 진행하려고 하는데, authentication credentials 등이 없다는 오류가 발생한다...
    Custom authentication을 해보자
    Django REST framework에 가서 API Guide에 Custom authentication 이용 https://www.django-rest-framework.org/api-guide/authentication/#custom-authentication

    (config/authentication.py) 생성, 바로 위에서 볼수 있는 Example 가져와서 수정
        from django.contrib.auth.models import User
        from rest_framework import authentication
        from rest_framework import exceptions

        class ExampleAuthentication(authentication.BaseAuthentication):
            def authenticate(self, request):
                username = request.META.get('HTTP_X_USERNAME')
                if not username:
                    return None

                try:
                    user = User.objects.get(username=username)
                except User.DoesNotExist:
                    raise exceptions.AuthenticationFailed('No such user')

                return (user, None)


        위의 내용을 다음과 같이 수정해보자 우선

        from django.contrib.auth.models import User
        from rest_framework import authentication
        from rest_framework import exceptions

        class JWTAuthentication(authentication.BaseAuthentication):
            def authenticate(self, request):
                print(request.META)

        그리고 settings.py에 추가
        (config/settings.py)
            REST_FRAMEWORK = {
                'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
                'PAGE_SIZE': 10,
                'DEFAULT_AUTHENTICATION_CLASSES': [
                    'config.authentication.JWTAuthentication',
                    'rest_framework.authentication.SessionAuthentication',
                ]
            }

        이렇게 해주고 JWTtoken을 보내면(어떤 프로그램으로 보내던데...) console에 HTTP_AUTHORIZATION = [JWT token 내용] 출력 됨
        이를 다시 출력해보자

        (config/authentication.py)
            class JWTAuthentication(authentication.BaseAuthentication):
                        def authenticate(self, request):
                            print(request.META.get("HTTP_AUTHORIZATION"))
        
        X-JWT를 구분해서 보려면(X-JWT는 관습적으로 붙음)
        (config/authentication.py)
            class JWTAuthentication(authentication.BaseAuthentication):
                def authenticate(self, request):
                    username = request.META.get('HTTP_X_USERNAME')
                    token = request.META.get("HTTP_AUTHORIZATION")
                    if token is None:
                        return None
                    xjwt, jwt_token = token.split(" ")
                    print(xjwt, jwt_token)

            이렇게 하면 X-JWT 와 JWT-token이 분리돼서 출력되는것 확인 가능

        (config/authentication.py)
            import jwt
            from django.conf import settings
            from rest_framework import authentication
            from users.models import User                                   # from django.contrib.auth.models import User 를 지우고 얘로 대체

            class JWTAuthentication(authentication.BaseAuthentication):
                def authenticate(self, request):
                    try:
                        token = request.META.get("HTTP_AUTHORIZATION")      # token을 HTTP로 부터 받아서 / # META로부터 header 등의 여러 정보를 얻을 수 있따. 잘 활용하자
                        if token is None:
                            return None
                        xjwt, jwt_token = token.split(" ")                  # token 구조를 분석하고
                        # jwt.decode(encoded_jwt, 'secret', algorithms=['HS256'])       # 기본 형식, pyjwt documentation 참고
                        decoded = jwt.decode(jwt_token, settings.SECRET_KEY, algorithms=['HS256'])  # decode 하고
                        pk = decoded.get("pk")                              
                        user = User.objects.get(pk=pk)                      # decode한 token으로 user도 찾고
                        return (user, None)                                 # 그 user를 return
                    except (ValueError, jwt.exceptions.DecodeError, User.DoesNotExist):
                        return None
                    # except ValueError:                                        # 위 except를 다음과 같이 2개로 나눠도 된다
                    #     return None
                    # except jwt.exceptions.DecodeError:
                    #     raise exceptions.AuthenticationFailed(detail="JWT Format Invalid")

        위와 같이 해서 우리 API가 JWT token을 받았을 떄, authentication을 하기 위해서 token을 어떻게 이해하는지 가르친 것임
        JWT Authentication 완료

    
# 2.13 JWT Recap
    TokenAuthentication을 이용할 수도 있다.
        Token과 JWT의 차이점: JWT는 database에 저장되지 않고, user에만 저장
        TokenAuthentication은 token의 일부를 database에 저장해둬야 한다.
        따라서 migration도 해주어야 하고, user를 위한 token을 생성해주어야 한다.
        이런 면에서 JWTAuthentication이 TokenAuthentication에 비해서 database측면에서 좋다.


# 2.14 Manual Pagination
    (rooms/views.py)
        from rest_framework.decorators import api_view

        @api_view(["GET"])
        def room_search(request):
            return Response()

    (rooms/urls.py)
        path("search/", views.room_search)

    여기까지 하고 확인하면 페이지는 Room Search 페이지가 우선 호출된다

    기존 RoomsView에서 5개 방만 가져왔었는데, pagination을 해보는 것으로 수정해보자

    (rooms/views.py)
        from rest_framework.pagination import PageNumberPagination


        class RoomsView(APIView):

            def get(self, request):
                paginator = PageNumberPagination()
                paginator.page_size = 20
                rooms = Room.objects.all()
                results = paginator.paginate_queryset(rooms, request)
                serializer = RoomSerializer(results, many=True).data
                return Response(serializer)

        # http://127.0.0.1:8000/api/v1/rooms/?page=2

    pagination 한 것을 최종적으로 적용하면,
    (rooms/views.py)
        from django.http.response import Http404
        from rest_framework.views import APIView
        from rest_framework.response import Response
        from rest_framework import status
        from rest_framework.decorators import api_view
        from rest_framework.pagination import PageNumberPagination
        from .models import Room
        from .serializers import RoomSerializer


        class RoomsView(APIView):

            def get(self, request):
                paginator = PageNumberPagination()
                paginator.page_size = 20
                rooms = Room.objects.all()
                results = paginator.paginate_queryset(rooms, request)
                serializer = RoomSerializer(results, many=True)                     # .data 아래에 적용
                return paginator.get_paginated_response(serializer.data)            # paginaton을 적용한 response로 바꿔주었다. # 다음이나 이전 페이지 url 등을 나타내준다.

            def post(self, request):
                if not request.user.is_authenticated:
                    return Response(status=status.HTTP_401_UNAUTHORIZED)
                serializer = RoomSerializer(data=request.data)
                if serializer.is_valid():
                    room = serializer.save(user=request.user)
                    room_serializer = RoomSerializer(room).data
                    return Response(data=room_serializer, status=status.HTTP_200_OK)
                else:
                    return Response(data=serializer.errors, status=status.HTTP_400_BAD_REQUEST)


        class RoomView(APIView):

            def get_room(self, pk):
                try:
                    room = Room.objects.get(pk=pk)
                    return room
                except Room.DoesNotExist:
                    return None

            def get(self, request, pk):
                room = self.get_room(pk)
                if room is not None:
                    serializer = RoomSerializer(room).data
                    return Response(serializer)
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)

            def put(self, request, pk):
                room = self.get_room(pk)
                if room is not None:
                    if room.user != request.user:
                        return Response(status=status.HTTP_403_FORBIDDEN)
                    serializer = RoomSerializer(
                        room, data=request.data, partial=True)
                    # print(serializer.is_valid(), serializer.errors)         # 오류가 나는지, 어떤 오류가 나는지를 파악해서 수정하자
                    if serializer.is_valid():
                        room = serializer.save()
                        return Response(RoomSerializer(room).data)
                    else:
                        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
                    return Response()
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)

            def delete(self, request, pk):
                room = self.get_room(pk)
                if room.user != request.user:
                    return Response(status=status.HTTP_403_FORBIDDEN)
                if room is not None:
                    room.delete()
                    return Response(status=status.HTTP_200_OK)
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)


        @api_view(["GET"])
        def room_search(request):
            paginator = PageNumberPagination()
            paginator.page_size = 10
            rooms = Room.objects.filter()
            results = paginator.paginate_queryset(rooms, request)
            serializer = RoomSerializer(results, many=True)
            return paginator.get_paginated_response(serializer.data)

    pagination 부분을 class로 처리해서, 중복되는 부분을 짧게 처리 가능.
    (rooms/views.py)
        from django.http.response import Http404
        from rest_framework.views import APIView
        from rest_framework.response import Response
        from rest_framework import status
        from rest_framework.decorators import api_view
        from rest_framework.pagination import PageNumberPagination
        from .models import Room
        from .serializers import RoomSerializer


        class OwnPagination(PageNumberPagination):          # class로 Pagination 처리
            page_size = 20

        class RoomsView(APIView):

            def get(self, request):
                paginator = OwnPagination()
                rooms = Room.objects.all()
                results = paginator.paginate_queryset(rooms, request)
                serializer = RoomSerializer(results, many=True)
                return paginator.get_paginated_response(serializer.data)

            def post(self, request):
                if not request.user.is_authenticated:
                    return Response(status=status.HTTP_401_UNAUTHORIZED)
                serializer = RoomSerializer(data=request.data)
                if serializer.is_valid():
                    room = serializer.save(user=request.user)
                    room_serializer = RoomSerializer(room).data
                    return Response(data=room_serializer, status=status.HTTP_200_OK)
                else:
                    return Response(data=serializer.errors, status=status.HTTP_400_BAD_REQUEST)


        class RoomView(APIView):

            def get_room(self, pk):
                try:
                    room = Room.objects.get(pk=pk)
                    return room
                except Room.DoesNotExist:
                    return None

            def get(self, request, pk):
                room = self.get_room(pk)
                if room is not None:
                    serializer = RoomSerializer(room).data
                    return Response(serializer)
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)

            def put(self, request, pk):
                room = self.get_room(pk)
                if room is not None:
                    if room.user != request.user:
                        return Response(status=status.HTTP_403_FORBIDDEN)
                    serializer = RoomSerializer(
                        room, data=request.data, partial=True)
                    # print(serializer.is_valid(), serializer.errors)         # 오류가 나는지, 어떤 오류가 나는지를 파악해서 수정하자
                    if serializer.is_valid():
                        room = serializer.save()
                        return Response(RoomSerializer(room).data)
                    else:
                        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
                    return Response()
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)

            def delete(self, request, pk):
                room = self.get_room(pk)
                if room.user != request.user:
                    return Response(status=status.HTTP_403_FORBIDDEN)
                if room is not None:
                    room.delete()
                    return Response(status=status.HTTP_200_OK)
                else:
                    return Response(status=status.HTTP_404_NOT_FOUND)


        @api_view(["GET"])
        def room_search(request):
            paginator = OwnPagination()
            rooms = Room.objects.filter()
            results = paginator.paginate_queryset(rooms, request)
            serializer = RoomSerializer(results, many=True)
            return paginator.get_paginated_response(serializer.data)


# 2.15 Searching Part One
    (rooms/views.py)
        @api_view(["GET"])
        def room_search(request):
            max_price = request.GET.get('max_price', None)
            min_price = request.GET.get('min_price', None)
            beds = request.GET.get('beds', None)
            bedrooms = request.GET.get('bedrooms', None)
            bath = request.GET.get('bath', None)
            paginator = OwnPagination()
            rooms = Room.objects.filter()
            results = paginator.paginate_queryset(rooms, request)
            serializer = RoomSerializer(results, many=True)
            return paginator.get_paginated_response(serializer.data)
        
    위와 같이해주고 http://127.0.0.1:8000/api/v1/rooms/search/?max_price=30 해보면, max_price가 argument로 제대로 작동하는것 확인 가능

    (rooms/views.py)
        def room_search(request):
            max_price = request.GET.get('max_price', None)
            min_price = request.GET.get('min_price', None)
            beds = request.GET.get('beds', None)
            bedrooms = request.GET.get('bedrooms', None)
            bathrooms = request.GET.get('bathrooms', None)
            filter_kwargs = {}
            if max_price is not None:
                filter_kwargs["price__lte"] = max_price
            if min_price is not None:
                filter_kwargs["price__gte"] = min_price
            if beds is not None:
                filter_kwargs["beds__gte"] = beds
            if bedrooms is not None:
                filter_kwargs["bedrooms__gte"] = bedrooms
            if bathrooms is not None:
                filter_kwargs["bathrooms__gte"] = bathrooms
            paginator = OwnPagination()
            try:
                rooms = Room.objects.filter(**filter_kwargs)
            except ValueError:
                rooms = Room.objects.all()
            results = paginator.paginate_queryset(rooms, request)
            serializer = RoomSerializer(results, many=True)
            return paginator.get_paginated_response(serializer.data)
